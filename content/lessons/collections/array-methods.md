# دوال المصفوفات الشائعة

في الدرس السابق تعلمنا كيفية إنشاء المصفوفات والتعامل معها. الآن سنتعرف على **الدوال المدمجة** التي تجعل العمل مع المصفوفات أسهل وأقوى.

## الوصول إلى العناصر

### first و last

للحصول على العناصر الأولى أو الأخيرة:

```ruby
numbers = [10, 20, 30, 40, 50]

# العنصر الأول
puts numbers.first    # 10

# العنصر الأخير
puts numbers.last     # 50

# أول 3 عناصر
p numbers.first(3)    # [10, 20, 30]

# آخر 2 عنصر
p numbers.last(2)     # [40, 50]
```

### take و drop

لأخذ عناصر من البداية أو تجاهلها:

```ruby
letters = ["أ", "ب", "ت", "ث", "ج"]

# خذ أول 3 عناصر
p letters.take(3)     # ["أ", "ب", "ت"]

# تجاهل أول 2 وخذ الباقي
p letters.drop(2)     # ["ت", "ث", "ج"]
```

## معلومات عن المصفوفة

### length و size و count

للحصول على عدد العناصر:

```ruby
fruits = ["تفاح", "موز", "برتقال", "تفاح", "عنب"]

puts fruits.length    # 5
puts fruits.size      # 5 (نفس length تماماً)
puts fruits.count     # 5 (نفس الشيء)

# count مع قيمة محددة
puts fruits.count("تفاح")    # 2 (عدد مرات ظهور "تفاح")

# count مع شرط
puts fruits.count { |f| f.length > 3 }  # 3 (عناصر أطول من 3 أحرف)
```

### empty? و any? و none?

للتحقق من محتويات المصفوفة:

```ruby
empty_array = []
numbers = [1, 2, 3, 4, 5]
zeros = [0, 0, 0]

# هل المصفوفة فارغة؟
puts empty_array.empty?    # true
puts numbers.empty?        # false

# هل يوجد أي عنصر يحقق الشرط؟
puts numbers.any? { |n| n > 3 }     # true (يوجد عناصر أكبر من 3)
puts zeros.any? { |n| n > 0 }       # false (لا يوجد عنصر أكبر من 0)

# هل لا يوجد أي عنصر يحقق الشرط؟
puts numbers.none? { |n| n < 0 }    # true (لا يوجد أرقام سالبة)
puts numbers.none? { |n| n > 2 }    # false (يوجد أرقام أكبر من 2)
```

### include?

للتحقق من وجود عنصر معين:

```ruby
colors = ["أحمر", "أخضر", "أزرق"]

puts colors.include?("أخضر")    # true
puts colors.include?("أصفر")    # false
```

### index و rindex

لإيجاد موضع عنصر:

```ruby
letters = ["أ", "ب", "ت", "ب", "ث"]

# موضع أول ظهور
puts letters.index("ب")     # 1

# موضع آخر ظهور
puts letters.rindex("ب")    # 3

# إذا لم يوجد العنصر
# لا شيء (nil)
puts letters.index("ج")
```

## ترتيب المصفوفة

### sort

لترتيب العناصر تصاعدياً:

```ruby
numbers = [5, 2, 8, 1, 9]
names = ["سارة", "أحمد", "محمد", "فاطمة"]

# ترتيب الأرقام
p numbers.sort    # [1, 2, 5, 8, 9]

# ترتيب النصوص (أبجدياً)
p names.sort      # ["أحمد", "سارة", "فاطمة", "محمد"]

# المصفوفة الأصلية لم تتغير
p numbers         # [5, 2, 8, 1, 9]
```

### sort مع ترتيب مخصص

```ruby
numbers = [5, 2, 8, 1, 9]

# ترتيب تنازلي
p numbers.sort.reverse              # [9, 8, 5, 2, 1]

# أو باستخدام block
p numbers.sort { |a, b| b <=> a }   # [9, 8, 5, 2, 1]

# ترتيب بحسب طول النص
words = ["تفاحة", "موز", "برتقال"]
p words.sort_by { |w| w.length }    # ["موز", "تفاحة", "برتقال"]
```

### reverse

لعكس ترتيب العناصر:

```ruby
numbers = [1, 2, 3, 4, 5]

p numbers.reverse    # [5, 4, 3, 2, 1]

# المصفوفة الأصلية لم تتغير
p numbers            # [1, 2, 3, 4, 5]

# للعكس مع التعديل استخدم reverse!
numbers.reverse!
p numbers            # [5, 4, 3, 2, 1]
```

### shuffle

لخلط العناصر عشوائياً:

```ruby
cards = ["1", "2", "3", "4", "5"]

# ترتيب عشوائي مختلف كل مرة
p cards.shuffle
```

## تنظيف المصفوفة

### uniq

لإزالة العناصر المكررة:

```ruby
numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]

p numbers.uniq    # [1, 2, 3, 4]

# المصفوفة الأصلية لم تتغير
p numbers         # [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]

# مثال مع نصوص
colors = ["أحمر", "أخضر", "أحمر", "أزرق", "أخضر"]
p colors.uniq     # ["أحمر", "أخضر", "أزرق"]
```

### compact

لإزالة قيم nil:

```ruby
data = [1, nil, 2, nil, 3, nil]

p data.compact    # [1, 2, 3]

# المصفوفة الأصلية لم تتغير
p data            # [1, nil, 2, nil, 3, nil]

# مثال عملي
results = [85, nil, 90, nil, 78]
puts "النتائج الفعلية: #{results.compact}"
```

### flatten

لتسطيح المصفوفات المتداخلة:

```ruby
# مصفوفة متداخلة
nested = [1, [2, 3], [4, [5, 6]]]

# تسطيح كامل
p nested.flatten         # [1, 2, 3, 4, 5, 6]

# تسطيح مستوى واحد فقط
p nested.flatten(1)      # [1, 2, 3, 4, [5, 6]]

# المصفوفة الأصلية لم تتغير
p nested                 # [1, [2, 3], [4, [5, 6]]]
```

مثال عملي:

```ruby
# قوائم تسوق من عدة أشخاص
lists = [
  ["حليب", "خبز"],
  ["بيض", "جبن"],
  ["تفاح", "موز", "برتقال"]
]

# دمج كل القوائم في قائمة واحدة
all_items = lists.flatten
p all_items    # ["حليب", "خبز", "بيض", "جبن", "تفاح", "موز", "برتقال"]
```

## جدول ملخص الدوال

| الدالة | الوصف | المثال |
|--------|--------|--------|
| `first` | العنصر الأول | `arr.first` → أول عنصر |
| `last` | العنصر الأخير | `arr.last` → آخر عنصر |
| `length` | عدد العناصر | `arr.length` → العدد |
| `include?` | هل يحتوي على قيمة؟ | `arr.include?(x)` → true/false |
| `sort` | ترتيب تصاعدي | `arr.sort` → مرتبة |
| `reverse` | عكس الترتيب | `arr.reverse` → معكوسة |
| `uniq` | إزالة التكرار | `arr.uniq` → بدون تكرار |
| `compact` | إزالة nil | `arr.compact` → بدون nil |
| `flatten` | تسطيح المتداخلة | `arr.flatten` → مسطحة |

## دوال إضافية مفيدة

### min و max و sum

```ruby
grades = [85, 90, 78, 92, 88]

puts grades.min     # 78 (أقل قيمة)
puts grades.max     # 92 (أعلى قيمة)
puts grades.sum     # 433 (مجموع القيم)

# حساب المتوسط
average = grades.sum / grades.length.to_f
puts average.round(2)    # 86.6
```

### minmax

للحصول على الأصغر والأكبر معاً:

```ruby
numbers = [5, 2, 8, 1, 9, 3]

min, max = numbers.minmax
puts "الأصغر: #{min}, الأكبر: #{max}"
# الأصغر: 1, الأكبر: 9
```

### sample

لاختيار عنصر عشوائي:

```ruby
colors = ["أحمر", "أخضر", "أزرق", "أصفر"]

# لون عشوائي واحد
puts colors.sample
# لونان عشوائيان
p colors.sample(2)
```

### join

لتحويل المصفوفة إلى نص:

```ruby
words = ["أنا", "أحب", "روبي"]

puts words.join         # "أناأحبروبي" (بدون فاصل)
puts words.join(" ")    # "أنا أحب روبي" (بمسافة)
puts words.join(", ")   # "أنا, أحب, روبي" (بفاصلة)
puts words.join("-")    # "أنا-أحب-روبي" (بشرطة)
```

### zip

لدمج عدة مصفوفات:

```ruby
names = ["أحمد", "سارة", "محمد"]
grades = [85, 92, 78]
statuses = ["ناجح", "ناجح", "ناجح"]

combined = names.zip(grades, statuses)
p combined
# [["أحمد", 85, "ناجح"], ["سارة", 92, "ناجح"], ["محمد", 78, "ناجح"]]
```

## أمثلة عملية

### مثال 1: تنظيف بيانات

```ruby
# بيانات غير نظيفة
raw_data = [nil, 5, 3, nil, 5, 8, 3, nil, 9, 5]

puts "البيانات الأصلية:"
p raw_data

# تنظيف: إزالة nil، إزالة التكرار، ترتيب
clean_data = raw_data.compact.uniq.sort

puts "البيانات النظيفة:"
p clean_data
# [3, 5, 8, 9]
```

### مثال 2: تحليل الدرجات

```ruby
grades = [85, 92, 78, 95, 88, 72, 90]

puts "تحليل الدرجات:"
puts "عدد الطلاب: #{grades.length}"
puts "أعلى درجة: #{grades.max}"
puts "أقل درجة: #{grades.min}"
puts "المجموع: #{grades.sum}"
puts "المتوسط: #{(grades.sum / grades.length.to_f).round(2)}"
puts "الدرجات مرتبة: #{grades.sort.join(', ')}"

# عدد الناجحين (60+)
passing = grades.count { |g| g >= 60 }
puts "عدد الناجحين: #{passing}"
```

الناتج:
```
تحليل الدرجات:
عدد الطلاب: 7
أعلى درجة: 95
أقل درجة: 72
المجموع: 600
المتوسط: 85.71
الدرجات مرتبة: 72, 78, 85, 88, 90, 92, 95
عدد الناجحين: 7
```

### مثال 3: معالجة قائمة أسماء

```ruby
# أسماء مع مسافات وتكرار وnil
names = [nil, "  أحمد  ", "سارة", nil, "أحمد", "  محمد", "سارة  "]

puts "الأسماء الأصلية:"
p names

# تنظيف وتجهيز القائمة
# إزالة nil
# إزالة المسافات
# إزالة التكرار
# ترتيب أبجدي
clean_names = names.compact
                   .map { |n| n.strip }
                   .uniq
                   .sort

puts "الأسماء النظيفة:"
p clean_names
# ["أحمد", "سارة", "محمد"]
```

### مثال 4: دمج قوائم مهام

```ruby
urgent = ["إنهاء التقرير", "الرد على البريد"]
today = ["اجتماع الفريق", "مراجعة الشيفرة"]
later = [["شراء هدية", ["تنظيف المكتب", "ترتيب الملفات"]]]

# دمج وتسطيح كل المهام
all_tasks = [urgent, today, later].flatten

puts "كل المهام:"
all_tasks.each_with_index do |task, i|
  puts "#{i + 1}. #{task}"
end
```

الناتج:
```
كل المهام:
1. إنهاء التقرير
2. الرد على البريد
3. اجتماع الفريق
4. مراجعة الشيفرة
5. شراء هدية
6. تنظيف المكتب
7. ترتيب الملفات
```

## نصائح مهمة

1. **معظم الدوال لا تعدل الأصل** - تُرجع مصفوفة جديدة
2. **استخدم ! للتعديل المباشر** - مثل `sort!` و `uniq!` و `compact!`
3. **سلسل الدوال معاً** - `arr.compact.uniq.sort` أنظف من خطوات منفصلة
4. **تحقق من الفراغ أولاً** - `if arr.any?` قبل العمليات
5. **استخدم count بدلاً من length للعد المشروط**

## الفرق بين الدوال العادية ودوال البانج (!)

```ruby
numbers = [3, 1, 4, 1, 5, 9, 2, 6]

# الدوال العادية تُرجع نسخة جديدة
sorted = numbers.sort
p sorted     # [1, 1, 2, 3, 4, 5, 6, 9]
p numbers    # [3, 1, 4, 1, 5, 9, 2, 6] (لم تتغير)

# دوال البانج تعدل المصفوفة الأصلية
numbers.sort!
p numbers    # [1, 1, 2, 3, 4, 5, 6, 9] (تغيرت)
```

## تمرين: تنظيف ومعالجة البيانات

حان وقت التطبيق! في محرر الشيفرة على اليسار:

**المطلوب:**

لديك مصفوفة بيانات غير نظيفة:
```ruby
data = [nil, 5, 3, nil, 8, 3, 5, nil, 9, 3, 1]
```

1. نظّف البيانات (أزل nil وأزل التكرار ورتّب تصاعدياً)
2. اطبع البيانات النظيفة باستخدام `p`
3. اطبع عدد العناصر بعد التنظيف
4. اطبع أول عنصر
5. اطبع آخر عنصر
6. اطبع مجموع العناصر
7. تحقق هل تحتوي على الرقم 5 (اطبع true أو false)

**تلميحات:**
- سلسل الدوال: `data.compact.uniq.sort`
- استخدم `.length` أو `.count` لعدد العناصر
- استخدم `.first` و `.last` للوصول
- استخدم `.sum` للمجموع
- استخدم `.include?(5)` للتحقق

الناتج المتوقع:
```
[1, 3, 5, 8, 9]
5
1
9
26
true
```

---

> **تذكّر:** دوال المصفوفات في روبي قوية جداً وتجعل معالجة البيانات سهلة وممتعة!
